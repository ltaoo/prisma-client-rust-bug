// Code generated by Prisma Client Rust. DO NOT EDIT.

use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::*;
use prisma_client_rust::query_core::{
    executor, schema_builder, BuildMode, QueryExecutor, QuerySchema,
};
use prisma_client_rust::DeleteResult;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
}
impl PrismaClient {
    pub async fn new() -> Self {
        let datamodel_str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:../dev.db\"\n}\n\ngenerator client {\n    provider      = \"prisma-client-rust\"\n    binaryTargets = [\"native\"]\n    output        = \"../src/db.rs\"\n}\n\nmodel User {\n    username    String @id\n    displayName String\n\n    posts    Post[]\n    comments Comment[]\n}\n\nmodel Post {\n    id      String @id\n    content String\n\n    comments Comment[] @relation()\n\n    User         User   @relation(fields: [userUsername], references: [username])\n    userUsername String\n}\n\nmodel Comment {\n    id String @id\n\n    postId String\n    post   Post   @relation(fields: [postId], references: [id])\n\n    User         User?   @relation(fields: [userUsername], references: [username])\n    userUsername String?\n}\n" ;
        let config = parse_configuration(datamodel_str).unwrap().subject;
        let source = config
            .datasources
            .first()
            .expect("Pleasy supply a datasource in your schema.prisma file");
        let url = if let Some(url) = source.load_shadow_database_url().unwrap() {
            url
        } else {
            source.load_url(|key| std::env::var(key).ok()).unwrap()
        };
        let (db_name, executor) = executor::load(&source, &[], &url).await.unwrap();
        let internal_model = InternalDataModelBuilder::new(&datamodel_str).build(db_name);
        let query_schema = Arc::new(schema_builder::build(
            internal_model,
            BuildMode::Modern,
            true,
            source.capabilities(),
            vec![],
            source.referential_integrity(),
        ));
        executor.primary_connector().get_connection().await.unwrap();
        Self {
            executor,
            query_schema,
        }
    }
    pub fn user(&self) -> UserActions {
        UserActions { client: &self }
    }
    pub fn post(&self) -> PostActions {
        PostActions { client: &self }
    }
    pub fn comment(&self) -> CommentActions {
        CommentActions { client: &self }
    }
}
fn user_outputs() -> Vec<Output> {
    vec![Output::new("username"), Output::new("displayName")]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserData {
    #[serde(rename = "username")]
    pub username: String,
    #[serde(rename = "displayName")]
    pub display_name: String,
    #[serde(rename = "posts")]
    posts: Option<Vec<PostData>>,
    #[serde(rename = "comments")]
    comments: Option<Vec<CommentData>>,
}
impl UserData {
    pub fn posts(&self) -> Result<&Vec<PostData>, String> {
        match &self.posts {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access posts but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
    pub fn comments(&self) -> Result<&Vec<CommentData>, String> {
        match &self.comments {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access comments but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct User {}
impl User {
    pub fn username() -> UserUsernameField {
        UserUsernameField {}
    }
    pub fn display_name() -> UserDisplayNameField {
        UserDisplayNameField {}
    }
    pub fn posts() -> UserPostsField {
        UserPostsField {}
    }
    pub fn comments() -> UserCommentsField {
        UserCommentsField {}
    }
    pub fn not(params: Vec<UserWhereParam>) -> UserWhereParam {
        UserWhereParam::Not(params)
    }
    pub fn or(params: Vec<UserWhereParam>) -> UserWhereParam {
        UserWhereParam::Or(params)
    }
    pub fn and(params: Vec<UserWhereParam>) -> UserWhereParam {
        UserWhereParam::And(params)
    }
}
pub struct UserUsernameField {}
pub struct UserSetUsername(String);
impl From<UserSetUsername> for UserSetParam {
    fn from(value: UserSetUsername) -> Self {
        Self::Username(value.0)
    }
}
impl UserUsernameField {
    pub fn contains(&self, value: String) -> UserWhereParam {
        UserWhereParam::UsernameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> UserWhereParam {
        UserWhereParam::UsernameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> UserWhereParam {
        UserWhereParam::UsernameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> UserWhereParam {
        UserWhereParam::UsernameEquals(value)
    }
    pub fn set<T: From<UserSetUsername>>(&self, value: String) -> T {
        UserSetUsername(value).into()
    }
}
pub struct UserDisplayNameField {}
pub struct UserSetDisplayName(String);
impl From<UserSetDisplayName> for UserSetParam {
    fn from(value: UserSetDisplayName) -> Self {
        Self::DisplayName(value.0)
    }
}
impl UserDisplayNameField {
    pub fn contains(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameEquals(value)
    }
    pub fn set<T: From<UserSetDisplayName>>(&self, value: String) -> T {
        UserSetDisplayName(value).into()
    }
}
pub struct UserPostsField {}
pub struct UserSetPosts(Vec<PostWhereParam>);
impl From<UserSetPosts> for UserSetParam {
    fn from(value: UserSetPosts) -> Self {
        Self::Posts(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl UserPostsField {
    pub fn some(&self, value: Vec<PostWhereParam>) -> UserWhereParam {
        UserWhereParam::PostsSome(value)
    }
    pub fn every(&self, value: Vec<PostWhereParam>) -> UserWhereParam {
        UserWhereParam::PostsEvery(value)
    }
    pub fn link<T: From<UserSetPosts>>(&self, value: Vec<PostWhereParam>) -> T {
        UserSetPosts(value).into()
    }
    pub fn fetch(&self, params: Vec<PostWhereParam>) -> UserWith {
        UserWithParam::Posts(params).into()
    }
}
pub struct UserCommentsField {}
pub struct UserSetComments(Vec<CommentWhereParam>);
impl From<UserSetComments> for UserSetParam {
    fn from(value: UserSetComments) -> Self {
        Self::Comments(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl UserCommentsField {
    pub fn some(&self, value: Vec<CommentWhereParam>) -> UserWhereParam {
        UserWhereParam::CommentsSome(value)
    }
    pub fn every(&self, value: Vec<CommentWhereParam>) -> UserWhereParam {
        UserWhereParam::CommentsEvery(value)
    }
    pub fn link<T: From<UserSetComments>>(&self, value: Vec<CommentWhereParam>) -> T {
        UserSetComments(value).into()
    }
    pub fn fetch(&self, params: Vec<CommentWhereParam>) -> UserWith {
        UserWithParam::Comments(params).into()
    }
}
pub struct UserActions<'a> {
    client: &'a PrismaClient,
}
pub enum UserWhereParam {
    UsernameContains(String),
    UsernameHasPrefix(String),
    UsernameHasSuffix(String),
    UsernameEquals(String),
    DisplayNameContains(String),
    DisplayNameHasPrefix(String),
    DisplayNameHasSuffix(String),
    DisplayNameEquals(String),
    PostsSome(Vec<PostWhereParam>),
    PostsEvery(Vec<PostWhereParam>),
    CommentsSome(Vec<CommentWhereParam>),
    CommentsEvery(Vec<CommentWhereParam>),
    Not(Vec<UserWhereParam>),
    Or(Vec<UserWhereParam>),
    And(Vec<UserWhereParam>),
}
impl UserWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::UsernameContains(value) => Field {
                name: "username".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UsernameHasPrefix(value) => Field {
                name: "username".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UsernameHasSuffix(value) => Field {
                name: "username".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UsernameEquals(value) => Field {
                name: "username".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameContains(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameHasPrefix(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameHasSuffix(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameEquals(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PostsSome(value) => Field {
                name: "posts".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PostsEvery(value) => Field {
                name: "posts".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CommentsSome(value) => Field {
                name: "comments".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CommentsEvery(value) => Field {
                name: "comments".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct UserWith {
    pub param: UserWithParam,
}
pub enum UserWithParam {
    Posts(Vec<PostWhereParam>),
    Comments(Vec<CommentWhereParam>),
}
impl From<UserWithParam> for UserWith {
    fn from(param: UserWithParam) -> Self {
        Self { param }
    }
}
impl UserWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Posts(where_params) => Output {
                name: "posts".into(),
                outputs: post_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
            Self::Comments(where_params) => Output {
                name: "comments".into(),
                outputs: comment_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum UserSetParam {
    Username(String),
    DisplayName(String),
    Posts(Vec<PostWhereParam>),
    Comments(Vec<CommentWhereParam>),
}
impl UserSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Username(value) => Field {
                name: "username".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::DisplayName(value) => Field {
                name: "displayName".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Posts(where_params) => Field {
                name: "posts".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Comments(where_params) => Field {
                name: "comments".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub struct UserFindMany<'a> {
    query: Query<'a>,
}
impl<'a> UserFindMany<'a> {
    pub async fn exec(self) -> Vec<UserData> {
        self.query.perform().await
    }
    pub fn delete(self) -> UserDelete<'a> {
        UserDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "User".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<UserWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct UserFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> UserFindFirst<'a> {
    pub async fn exec(self) -> UserData {
        self.query.perform().await
    }
    pub fn with(mut self, fetches: Vec<UserWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct UserFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> UserFindUnique<'a> {
    pub async fn exec(self) -> UserData {
        self.query.perform().await
    }
    pub fn delete(self) -> UserDelete<'a> {
        UserDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "User".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<UserWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct UserCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> UserCreateOne<'a> {
    pub async fn exec(self) -> UserData {
        self.query.perform().await
    }
}
pub struct UserDelete<'a> {
    query: Query<'a>,
}
impl<'a> UserDelete<'a> {
    pub async fn exec(self) -> isize {
        let result: DeleteResult = self.query.perform().await;
        result.count
    }
}
impl<'a> UserActions<'a> {
    pub fn find_unique(&self, param: UserWhereParam) -> UserFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        UserFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<UserWhereParam>) -> UserFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs,
        };
        UserFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<UserWhereParam>) -> UserFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs,
        };
        UserFindMany { query }
    }
    pub fn create_one(
        &self,
        username: UserSetUsername,
        display_name: UserSetDisplayName,
        params: Vec<UserSetParam>,
    ) -> UserCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(UserSetParam::from(username).field());
        input_fields.push(UserSetParam::from(display_name).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        UserCreateOne { query }
    }
}
fn post_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("content"),
        Output::new("userUsername"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostData {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "content")]
    pub content: String,
    #[serde(rename = "comments")]
    comments: Option<Vec<CommentData>>,
    #[serde(rename = "User")]
    user: Option<UserData>,
    #[serde(rename = "userUsername")]
    pub user_username: String,
}
impl PostData {
    pub fn comments(&self) -> Result<&Vec<CommentData>, String> {
        match &self.comments {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access comments but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
    pub fn user(&self) -> Result<&UserData, String> {
        match &self.user {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access user but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct Post {}
impl Post {
    pub fn id() -> PostIdField {
        PostIdField {}
    }
    pub fn content() -> PostContentField {
        PostContentField {}
    }
    pub fn comments() -> PostCommentsField {
        PostCommentsField {}
    }
    pub fn user() -> PostUserField {
        PostUserField {}
    }
    pub fn user_username() -> PostUserUsernameField {
        PostUserUsernameField {}
    }
    pub fn not(params: Vec<PostWhereParam>) -> PostWhereParam {
        PostWhereParam::Not(params)
    }
    pub fn or(params: Vec<PostWhereParam>) -> PostWhereParam {
        PostWhereParam::Or(params)
    }
    pub fn and(params: Vec<PostWhereParam>) -> PostWhereParam {
        PostWhereParam::And(params)
    }
}
pub struct PostIdField {}
pub struct PostSetId(String);
impl From<PostSetId> for PostSetParam {
    fn from(value: PostSetId) -> Self {
        Self::Id(value.0)
    }
}
impl PostIdField {
    pub fn contains(&self, value: String) -> PostWhereParam {
        PostWhereParam::IdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PostWhereParam {
        PostWhereParam::IdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PostWhereParam {
        PostWhereParam::IdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PostWhereParam {
        PostWhereParam::IdEquals(value)
    }
    pub fn set<T: From<PostSetId>>(&self, value: String) -> T {
        PostSetId(value).into()
    }
}
pub struct PostContentField {}
pub struct PostSetContent(String);
impl From<PostSetContent> for PostSetParam {
    fn from(value: PostSetContent) -> Self {
        Self::Content(value.0)
    }
}
impl PostContentField {
    pub fn contains(&self, value: String) -> PostWhereParam {
        PostWhereParam::ContentContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PostWhereParam {
        PostWhereParam::ContentHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PostWhereParam {
        PostWhereParam::ContentHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PostWhereParam {
        PostWhereParam::ContentEquals(value)
    }
    pub fn set<T: From<PostSetContent>>(&self, value: String) -> T {
        PostSetContent(value).into()
    }
}
pub struct PostCommentsField {}
pub struct PostSetComments(Vec<CommentWhereParam>);
impl From<PostSetComments> for PostSetParam {
    fn from(value: PostSetComments) -> Self {
        Self::Comments(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl PostCommentsField {
    pub fn some(&self, value: Vec<CommentWhereParam>) -> PostWhereParam {
        PostWhereParam::CommentsSome(value)
    }
    pub fn every(&self, value: Vec<CommentWhereParam>) -> PostWhereParam {
        PostWhereParam::CommentsEvery(value)
    }
    pub fn link<T: From<PostSetComments>>(&self, value: Vec<CommentWhereParam>) -> T {
        PostSetComments(value).into()
    }
    pub fn fetch(&self, params: Vec<CommentWhereParam>) -> PostWith {
        PostWithParam::Comments(params).into()
    }
}
pub struct PostUserField {}
pub struct PostSetUser(UserWhereParam);
impl From<PostSetUser> for PostSetParam {
    fn from(value: PostSetUser) -> Self {
        Self::User(value.0)
    }
}
impl PostUserField {
    pub fn is(&self, value: Vec<UserWhereParam>) -> PostWhereParam {
        PostWhereParam::UserIs(value)
    }
    pub fn link<T: From<PostSetUser>>(&self, value: UserWhereParam) -> T {
        PostSetUser(value).into()
    }
    pub fn fetch(&self) -> PostWith {
        PostWithParam::User.into()
    }
}
pub struct PostUserUsernameField {}
pub struct PostSetUserUsername(String);
impl From<PostSetUserUsername> for PostSetParam {
    fn from(value: PostSetUserUsername) -> Self {
        Self::UserUsername(value.0)
    }
}
impl PostUserUsernameField {
    pub fn contains(&self, value: String) -> PostWhereParam {
        PostWhereParam::UserUsernameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PostWhereParam {
        PostWhereParam::UserUsernameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PostWhereParam {
        PostWhereParam::UserUsernameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PostWhereParam {
        PostWhereParam::UserUsernameEquals(value)
    }
    pub fn set<T: From<PostSetUserUsername>>(&self, value: String) -> T {
        PostSetUserUsername(value).into()
    }
}
pub struct PostActions<'a> {
    client: &'a PrismaClient,
}
pub enum PostWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
    ContentContains(String),
    ContentHasPrefix(String),
    ContentHasSuffix(String),
    ContentEquals(String),
    CommentsSome(Vec<CommentWhereParam>),
    CommentsEvery(Vec<CommentWhereParam>),
    UserIs(Vec<UserWhereParam>),
    UserUsernameContains(String),
    UserUsernameHasPrefix(String),
    UserUsernameHasSuffix(String),
    UserUsernameEquals(String),
    Not(Vec<PostWhereParam>),
    Or(Vec<PostWhereParam>),
    And(Vec<PostWhereParam>),
}
impl PostWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdContains(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasPrefix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasSuffix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ContentContains(value) => Field {
                name: "content".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ContentHasPrefix(value) => Field {
                name: "content".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ContentHasSuffix(value) => Field {
                name: "content".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ContentEquals(value) => Field {
                name: "content".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CommentsSome(value) => Field {
                name: "comments".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::CommentsEvery(value) => Field {
                name: "comments".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserIs(value) => Field {
                name: "User".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsernameContains(value) => Field {
                name: "userUsername".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsernameHasPrefix(value) => Field {
                name: "userUsername".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsernameHasSuffix(value) => Field {
                name: "userUsername".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsernameEquals(value) => Field {
                name: "userUsername".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct PostWith {
    pub param: PostWithParam,
}
pub enum PostWithParam {
    Comments(Vec<CommentWhereParam>),
    User,
}
impl From<PostWithParam> for PostWith {
    fn from(param: PostWithParam) -> Self {
        Self { param }
    }
}
impl PostWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Comments(where_params) => Output {
                name: "comments".into(),
                outputs: comment_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
            Self::User => Output {
                name: "User".into(),
                outputs: user_outputs(),
                ..Default::default()
            },
        }
    }
}
pub enum PostSetParam {
    Id(String),
    Content(String),
    Comments(Vec<CommentWhereParam>),
    User(UserWhereParam),
    UserUsername(String),
}
impl PostSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Content(value) => Field {
                name: "content".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Comments(where_params) => Field {
                name: "comments".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params.into_iter().map(|item| item.field()).collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::User(where_param) => Field {
                name: "User".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsername(value) => Field {
                name: "userUsername".into(),
                value: Some(value.into()),
                ..Default::default()
            },
        }
    }
}
pub struct PostFindMany<'a> {
    query: Query<'a>,
}
impl<'a> PostFindMany<'a> {
    pub async fn exec(self) -> Vec<PostData> {
        self.query.perform().await
    }
    pub fn delete(self) -> PostDelete<'a> {
        PostDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Post".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<PostWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct PostFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> PostFindFirst<'a> {
    pub async fn exec(self) -> PostData {
        self.query.perform().await
    }
    pub fn with(mut self, fetches: Vec<PostWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct PostFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> PostFindUnique<'a> {
    pub async fn exec(self) -> PostData {
        self.query.perform().await
    }
    pub fn delete(self) -> PostDelete<'a> {
        PostDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Post".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<PostWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct PostCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> PostCreateOne<'a> {
    pub async fn exec(self) -> PostData {
        self.query.perform().await
    }
}
pub struct PostDelete<'a> {
    query: Query<'a>,
}
impl<'a> PostDelete<'a> {
    pub async fn exec(self) -> isize {
        let result: DeleteResult = self.query.perform().await;
        result.count
    }
}
impl<'a> PostActions<'a> {
    pub fn find_unique(&self, param: PostWhereParam) -> PostFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Post".into(),
            outputs: post_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        PostFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<PostWhereParam>) -> PostFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Post".into(),
            outputs: post_outputs(),
            inputs,
        };
        PostFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<PostWhereParam>) -> PostFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Post".into(),
            outputs: post_outputs(),
            inputs,
        };
        PostFindMany { query }
    }
    pub fn create_one(
        &self,
        id: PostSetId,
        content: PostSetContent,
        user: PostSetUser,
        params: Vec<PostSetParam>,
    ) -> PostCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(PostSetParam::from(id).field());
        input_fields.push(PostSetParam::from(content).field());
        input_fields.push(PostSetParam::from(user).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Post".into(),
            outputs: post_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        PostCreateOne { query }
    }
}
fn comment_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("postId"),
        Output::new("userUsername"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommentData {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "postId")]
    pub post_id: String,
    #[serde(rename = "post")]
    post: Option<PostData>,
    #[serde(rename = "User")]
    pub user: Option<UserData>,
    #[serde(rename = "userUsername")]
    pub user_username: Option<String>,
}
impl CommentData {
    pub fn post(&self) -> Result<&PostData, String> {
        match &self.post {
            Some(v) => Ok(v),
            None => Err(
                "attempted to access post but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
    pub fn user(&self) -> Option<&UserData> {
        self.user.as_ref()
    }
}
pub struct Comment {}
impl Comment {
    pub fn id() -> CommentIdField {
        CommentIdField {}
    }
    pub fn post_id() -> CommentPostIdField {
        CommentPostIdField {}
    }
    pub fn post() -> CommentPostField {
        CommentPostField {}
    }
    pub fn user() -> CommentUserField {
        CommentUserField {}
    }
    pub fn user_username() -> CommentUserUsernameField {
        CommentUserUsernameField {}
    }
    pub fn not(params: Vec<CommentWhereParam>) -> CommentWhereParam {
        CommentWhereParam::Not(params)
    }
    pub fn or(params: Vec<CommentWhereParam>) -> CommentWhereParam {
        CommentWhereParam::Or(params)
    }
    pub fn and(params: Vec<CommentWhereParam>) -> CommentWhereParam {
        CommentWhereParam::And(params)
    }
}
pub struct CommentIdField {}
pub struct CommentSetId(String);
impl From<CommentSetId> for CommentSetParam {
    fn from(value: CommentSetId) -> Self {
        Self::Id(value.0)
    }
}
impl CommentIdField {
    pub fn contains(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::IdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::IdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::IdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::IdEquals(value)
    }
    pub fn set<T: From<CommentSetId>>(&self, value: String) -> T {
        CommentSetId(value).into()
    }
}
pub struct CommentPostIdField {}
pub struct CommentSetPostId(String);
impl From<CommentSetPostId> for CommentSetParam {
    fn from(value: CommentSetPostId) -> Self {
        Self::PostId(value.0)
    }
}
impl CommentPostIdField {
    pub fn contains(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::PostIdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::PostIdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::PostIdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::PostIdEquals(value)
    }
    pub fn set<T: From<CommentSetPostId>>(&self, value: String) -> T {
        CommentSetPostId(value).into()
    }
}
pub struct CommentPostField {}
pub struct CommentSetPost(PostWhereParam);
impl From<CommentSetPost> for CommentSetParam {
    fn from(value: CommentSetPost) -> Self {
        Self::Post(value.0)
    }
}
impl CommentPostField {
    pub fn is(&self, value: Vec<PostWhereParam>) -> CommentWhereParam {
        CommentWhereParam::PostIs(value)
    }
    pub fn link<T: From<CommentSetPost>>(&self, value: PostWhereParam) -> T {
        CommentSetPost(value).into()
    }
    pub fn fetch(&self) -> CommentWith {
        CommentWithParam::Post.into()
    }
}
pub struct CommentUserField {}
pub struct CommentSetUser(UserWhereParam);
impl From<CommentSetUser> for CommentSetParam {
    fn from(value: CommentSetUser) -> Self {
        Self::User(value.0)
    }
}
impl CommentUserField {
    pub fn is(&self, value: Vec<UserWhereParam>) -> CommentWhereParam {
        CommentWhereParam::UserIs(value)
    }
    pub fn link<T: From<CommentSetUser>>(&self, value: UserWhereParam) -> T {
        CommentSetUser(value).into()
    }
    pub fn fetch(&self) -> CommentWith {
        CommentWithParam::User.into()
    }
}
pub struct CommentUserUsernameField {}
pub struct CommentSetUserUsername(String);
impl From<CommentSetUserUsername> for CommentSetParam {
    fn from(value: CommentSetUserUsername) -> Self {
        Self::UserUsername(value.0)
    }
}
impl CommentUserUsernameField {
    pub fn contains(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::UserUsernameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::UserUsernameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::UserUsernameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> CommentWhereParam {
        CommentWhereParam::UserUsernameEquals(value)
    }
    pub fn set<T: From<CommentSetUserUsername>>(&self, value: String) -> T {
        CommentSetUserUsername(value).into()
    }
}
pub struct CommentActions<'a> {
    client: &'a PrismaClient,
}
pub enum CommentWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
    PostIdContains(String),
    PostIdHasPrefix(String),
    PostIdHasSuffix(String),
    PostIdEquals(String),
    PostIs(Vec<PostWhereParam>),
    UserIs(Vec<UserWhereParam>),
    UserUsernameContains(String),
    UserUsernameHasPrefix(String),
    UserUsernameHasSuffix(String),
    UserUsernameEquals(String),
    Not(Vec<CommentWhereParam>),
    Or(Vec<CommentWhereParam>),
    And(Vec<CommentWhereParam>),
}
impl CommentWhereParam {
    pub fn field(self) -> Field {
        match self {
            Self::IdContains(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasPrefix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasSuffix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PostIdContains(value) => Field {
                name: "postId".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PostIdHasPrefix(value) => Field {
                name: "postId".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PostIdHasSuffix(value) => Field {
                name: "postId".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PostIdEquals(value) => Field {
                name: "postId".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PostIs(value) => Field {
                name: "post".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserIs(value) => Field {
                name: "User".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsernameContains(value) => Field {
                name: "userUsername".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsernameHasPrefix(value) => Field {
                name: "userUsername".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsernameHasSuffix(value) => Field {
                name: "userUsername".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsernameEquals(value) => Field {
                name: "userUsername".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(value.into()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.field()).collect()),
                ..Default::default()
            },
        }
    }
}
pub struct CommentWith {
    pub param: CommentWithParam,
}
pub enum CommentWithParam {
    Post,
    User,
}
impl From<CommentWithParam> for CommentWith {
    fn from(param: CommentWithParam) -> Self {
        Self { param }
    }
}
impl CommentWithParam {
    pub fn output(self) -> Output {
        match self {
            Self::Post => Output {
                name: "post".into(),
                outputs: post_outputs(),
                ..Default::default()
            },
            Self::User => Output {
                name: "User".into(),
                outputs: user_outputs(),
                ..Default::default()
            },
        }
    }
}
pub enum CommentSetParam {
    Id(String),
    PostId(String),
    Post(PostWhereParam),
    User(UserWhereParam),
    UserUsername(String),
}
impl CommentSetParam {
    pub fn field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::PostId(value) => Field {
                name: "postId".into(),
                value: Some(value.into()),
                ..Default::default()
            },
            Self::Post(where_param) => Field {
                name: "post".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::User(where_param) => Field {
                name: "User".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserUsername(value) => Field {
                name: "userUsername".into(),
                value: Some(value.into()),
                ..Default::default()
            },
        }
    }
}
pub struct CommentFindMany<'a> {
    query: Query<'a>,
}
impl<'a> CommentFindMany<'a> {
    pub async fn exec(self) -> Vec<CommentData> {
        self.query.perform().await
    }
    pub fn delete(self) -> CommentDelete<'a> {
        CommentDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Comment".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<CommentWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct CommentFindFirst<'a> {
    query: Query<'a>,
}
impl<'a> CommentFindFirst<'a> {
    pub async fn exec(self) -> CommentData {
        self.query.perform().await
    }
    pub fn with(mut self, fetches: Vec<CommentWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct CommentFindUnique<'a> {
    query: Query<'a>,
}
impl<'a> CommentFindUnique<'a> {
    pub async fn exec(self) -> CommentData {
        self.query.perform().await
    }
    pub fn delete(self) -> CommentDelete<'a> {
        CommentDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Comment".into(),
                ..self.query
            },
        }
    }
    pub fn with(mut self, fetches: Vec<CommentWith>) -> Self {
        let outputs = fetches
            .into_iter()
            .map(|f| f.param.output())
            .collect::<Vec<_>>();
        self.query.outputs.extend(outputs);
        self
    }
}
pub struct CommentCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> CommentCreateOne<'a> {
    pub async fn exec(self) -> CommentData {
        self.query.perform().await
    }
}
pub struct CommentDelete<'a> {
    query: Query<'a>,
}
impl<'a> CommentDelete<'a> {
    pub async fn exec(self) -> isize {
        let result: DeleteResult = self.query.perform().await;
        result.count
    }
}
impl<'a> CommentActions<'a> {
    pub fn find_unique(&self, param: CommentWhereParam) -> CommentFindUnique {
        let fields = transform_equals(vec![param.field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Comment".into(),
            outputs: comment_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        CommentFindUnique { query }
    }
    pub fn find_first(&self, params: Vec<CommentWhereParam>) -> CommentFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Comment".into(),
            outputs: comment_outputs(),
            inputs,
        };
        CommentFindFirst { query }
    }
    pub fn find_many(&self, params: Vec<CommentWhereParam>) -> CommentFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Comment".into(),
            outputs: comment_outputs(),
            inputs,
        };
        CommentFindMany { query }
    }
    pub fn create_one(
        &self,
        id: CommentSetId,
        post: CommentSetPost,
        params: Vec<CommentSetParam>,
    ) -> CommentCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.field()).collect::<Vec<_>>();
        input_fields.push(CommentSetParam::from(id).field());
        input_fields.push(CommentSetParam::from(post).field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Comment".into(),
            outputs: comment_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        CommentCreateOne { query }
    }
}
